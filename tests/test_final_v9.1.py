#!/usr/bin/env python3
"""
BestStag v9.1 + Abacus.AI - Script de Valida√ß√£o Final
Consolida e valida toda a implementa√ß√£o das Fases 1, 2 e 3
"""

import os
import sys
import json
import asyncio
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple, Any
from dotenv import load_dotenv

# Carregar vari√°veis de ambiente
load_dotenv()

class BestStagValidator:
    """Validador completo do BestStag v9.1 + Abacus.AI"""
    
    def __init__(self):
        self.base_path = Path(__file__).parent
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "version": "9.1.0",
            "tests": {},
            "summary": {},
            "recommendations": []
        }
        self.success_count = 0
        self.total_tests = 0
    
    def log_test(self, test_name: str, success: bool, details: str = "", error: str = ""):
        """Registra resultado de um teste"""
        self.total_tests += 1
        if success:
            self.success_count += 1
            print(f"‚úÖ {test_name}")
        else:
            print(f"‚ùå {test_name}")
            if error:
                print(f"   Erro: {error}")
        
        self.results["tests"][test_name] = {
            "success": success,
            "details": details,
            "error": error,
            "timestamp": datetime.now().isoformat()
        }
        
        if details:
            print(f"   {details}")
    
    def check_file_structure(self) -> bool:
        """Valida estrutura de arquivos do projeto"""
        print("\nüìÅ Validando Estrutura de Arquivos")
        print("-" * 50)
        
        required_files = [
            # Fase 1 - Integra√ß√£o Inicial
            "nodes/AbacusAI.node.ts",
            "credentials/AbacusApi.credentials.ts",
            "workflows/whatsapp_abacus_workflow.json",
            "python/abacus_client.py",
            "requirements.txt",
            ".env.example",
            "test_integration.py",
            "README_FASE1.md",
            
            # Fase 2 - IA Contextual
            "python/contextual_memory.py",
            "python/intelligent_reports.py",
            "frontend/hooks/useAI.ts",
            "frontend/components/AIComponents.tsx",
            "requirements_fase2.txt",
            "test_fase2.py",
            "README_FASE2.md",
            
            # Fase 3 - Consolida√ß√£o
            "DOCUMENTACAO_TECNICA_COMPLETA.md",
            "CHANGELOG.md",
            "test_final_v9.1.py"
        ]
        
        missing_files = []
        existing_files = []
        
        for file_path in required_files:
            full_path = self.base_path / file_path
            if full_path.exists():
                existing_files.append(file_path)
                size = full_path.stat().st_size
                self.log_test(f"Arquivo {file_path}", True, f"Tamanho: {size} bytes")
            else:
                missing_files.append(file_path)
                self.log_test(f"Arquivo {file_path}", False, error="Arquivo n√£o encontrado")
        
        # Verificar estrutura de diret√≥rios
        required_dirs = [
            "nodes", "credentials", "workflows", "python", 
            "frontend/hooks", "frontend/components"
        ]
        
        for dir_path in required_dirs:
            full_path = self.base_path / dir_path
            if full_path.exists() and full_path.is_dir():
                self.log_test(f"Diret√≥rio {dir_path}", True)
            else:
                self.log_test(f"Diret√≥rio {dir_path}", False, error="Diret√≥rio n√£o encontrado")
                missing_files.append(dir_path)
        
        success = len(missing_files) == 0
        
        if missing_files:
            self.results["recommendations"].append(
                f"Criar arquivos/diret√≥rios faltando: {', '.join(missing_files)}"
            )
        
        return success
    
    def check_dependencies(self) -> bool:
        """Verifica depend√™ncias Python"""
        print("\nüì¶ Validando Depend√™ncias Python")
        print("-" * 50)
        
        # Depend√™ncias cr√≠ticas
        critical_deps = [
            ('requests', 'requests'),
            ('numpy', 'numpy'),
            ('sentence_transformers', 'sentence-transformers'),
            ('faiss', 'faiss-cpu'),
            ('dotenv', 'python-dotenv'),
            ('aiohttp', 'aiohttp'),
            ('pydantic', 'pydantic')
        ]
        
        missing_deps = []
        
        for module_name, package_name in critical_deps:
            try:
                __import__(module_name)
                self.log_test(f"Depend√™ncia {package_name}", True)
            except ImportError:
                self.log_test(f"Depend√™ncia {package_name}", False, 
                            error=f"Instale com: pip install {package_name}")
                missing_deps.append(package_name)
        
        # Verificar vers√µes espec√≠ficas
        version_checks = [
            ('sentence_transformers', '2.2.0'),
            ('numpy', '1.24.0'),
            ('aiohttp', '3.8.0')
        ]
        
        for module_name, min_version in version_checks:
            try:
                module = __import__(module_name)
                if hasattr(module, '__version__'):
                    version = module.__version__
                    self.log_test(f"Vers√£o {module_name}", True, f"v{version}")
                else:
                    self.log_test(f"Vers√£o {module_name}", True, "Vers√£o n√£o detect√°vel")
            except ImportError:
                pass  # J√° reportado acima
        
        if missing_deps:
            self.results["recommendations"].append(
                f"Instalar depend√™ncias: pip install {' '.join(missing_deps)}"
            )
        
        return len(missing_deps) == 0
    
    def check_configuration(self) -> bool:
        """Verifica configura√ß√£o do sistema"""
        print("\n‚öôÔ∏è Validando Configura√ß√£o")
        print("-" * 50)
        
        # Verificar arquivo .env.example
        env_example = self.base_path / ".env.example"
        if env_example.exists():
            self.log_test("Arquivo .env.example", True)
            
            # Verificar vari√°veis essenciais
            with open(env_example, 'r') as f:
                content = f.read()
                
            required_vars = [
                'ABACUS_API_KEY',
                'TWILIO_ACCOUNT_SID',
                'TWILIO_AUTH_TOKEN',
                'AIRTABLE_API_KEY',
                'EMBEDDING_MODEL',
                'MEMORY_MAX_ITEMS'
            ]
            
            for var in required_vars:
                if var in content:
                    self.log_test(f"Vari√°vel {var}", True)
                else:
                    self.log_test(f"Vari√°vel {var}", False, 
                                error="Vari√°vel n√£o encontrada no .env.example")
        else:
            self.log_test("Arquivo .env.example", False, error="Arquivo n√£o encontrado")
        
        # Verificar configura√ß√£o atual
        config_vars = [
            ('ABACUS_API_KEY', 'Chave API Abacus.AI'),
            ('TWILIO_ACCOUNT_SID', 'Twilio Account SID'),
            ('AIRTABLE_API_KEY', 'Airtable API Key')
        ]
        
        for var_name, description in config_vars:
            value = os.getenv(var_name)
            if value:
                self.log_test(f"Config {description}", True, "Configurado")
            else:
                self.log_test(f"Config {description}", False, 
                            error=f"Vari√°vel {var_name} n√£o configurada")
        
        return True  # Configura√ß√£o √© opcional para testes
    
    async def test_abacus_integration(self) -> bool:
        """Testa integra√ß√£o com Abacus.AI"""
        print("\nü§ñ Testando Integra√ß√£o Abacus.AI")
        print("-" * 50)
        
        try:
            # Importar cliente
            sys.path.append(str(self.base_path / "python"))
            from abacus_client import AbacusClient
            
            self.log_test("Importa√ß√£o AbacusClient", True)
            
            # Verificar se API key est√° configurada
            api_key = os.getenv("ABACUS_API_KEY")
            if not api_key:
                self.log_test("API Key Abacus.AI", False, 
                            error="ABACUS_API_KEY n√£o configurada - usando modo simula√ß√£o")
                return True  # N√£o √© erro cr√≠tico
            
            # Inicializar cliente
            client = AbacusClient(api_key=api_key)
            self.log_test("Inicializa√ß√£o cliente", True)
            
            # Teste de health check
            if client.health_check():
                self.log_test("Health check Abacus.AI", True)
                
                # Teste b√°sico de gera√ß√£o de texto
                try:
                    response = client.generate_text(
                        prompt="Teste de integra√ß√£o BestStag v9.1",
                        model="gpt-3.5-turbo",
                        max_tokens=50
                    )
                    
                    if response and 'response' in response:
                        self.log_test("Gera√ß√£o de texto", True, 
                                    f"Resposta: {response['response'][:50]}...")
                    else:
                        self.log_test("Gera√ß√£o de texto", False, 
                                    error="Resposta inv√°lida")
                        
                except Exception as e:
                    self.log_test("Gera√ß√£o de texto", False, error=str(e))
                    
            else:
                self.log_test("Health check Abacus.AI", False, 
                            error="API n√£o est√° respondendo")
                
        except ImportError as e:
            self.log_test("Importa√ß√£o AbacusClient", False, error=str(e))
            return False
        except Exception as e:
            self.log_test("Teste Abacus.AI", False, error=str(e))
            return False
        
        return True
    
    async def test_contextual_memory(self) -> bool:
        """Testa sistema de mem√≥ria contextual"""
        print("\nüß† Testando Sistema de Mem√≥ria Contextual")
        print("-" * 50)
        
        try:
            sys.path.append(str(self.base_path / "python"))
            from contextual_memory import ContextualMemorySystem
            
            self.log_test("Importa√ß√£o ContextualMemorySystem", True)
            
            # Inicializar sistema
            memory = ContextualMemorySystem()
            self.log_test("Inicializa√ß√£o mem√≥ria", True)
            
            # Teste de adi√ß√£o de mem√≥ria
            memory_id = memory.add_memory(
                content="Teste de mem√≥ria contextual BestStag v9.1",
                user_id="test_user_validation",
                category="teste",
                importance=0.8
            )
            
            if memory_id:
                self.log_test("Adi√ß√£o de mem√≥ria", True, f"ID: {memory_id}")
            else:
                self.log_test("Adi√ß√£o de mem√≥ria", False, error="ID n√£o retornado")
                return False
            
            # Teste de busca
            results = memory.search_memory(
                query="teste mem√≥ria",
                user_id="test_user_validation",
                top_k=1
            )
            
            if results and len(results) > 0:
                self.log_test("Busca sem√¢ntica", True, 
                            f"Encontrados {len(results)} resultados")
                
                # Verificar score de similaridade
                score = results[0].metadata.get('similarity_score', 0)
                if score > 0.5:
                    self.log_test("Score de similaridade", True, f"Score: {score:.3f}")
                else:
                    self.log_test("Score de similaridade", False, 
                                f"Score muito baixo: {score:.3f}")
            else:
                self.log_test("Busca sem√¢ntica", False, error="Nenhum resultado encontrado")
            
            # Teste de contexto do usu√°rio
            context = memory.get_user_context("test_user_validation")
            if context and 'total_items' in context:
                self.log_test("Contexto do usu√°rio", True, 
                            f"Total de itens: {context['total_items']}")
            else:
                self.log_test("Contexto do usu√°rio", False, error="Contexto inv√°lido")
            
            # Teste de estat√≠sticas
            stats = memory.get_stats()
            if stats and 'total_items' in stats:
                self.log_test("Estat√≠sticas da mem√≥ria", True, 
                            f"Total: {stats['total_items']}, Modelo: {stats.get('model_name', 'N/A')}")
            else:
                self.log_test("Estat√≠sticas da mem√≥ria", False, error="Estat√≠sticas inv√°lidas")
                
        except ImportError as e:
            self.log_test("Importa√ß√£o ContextualMemorySystem", False, error=str(e))
            return False
        except Exception as e:
            self.log_test("Teste mem√≥ria contextual", False, error=str(e))
            return False
        
        return True
    
    def test_frontend_structure(self) -> bool:
        """Testa estrutura do frontend"""
        print("\n‚öõÔ∏è Testando Estrutura Frontend")
        print("-" * 50)
        
        frontend_files = [
            ('frontend/hooks/useAI.ts', 'Hooks React IA'),
            ('frontend/components/AIComponents.tsx', 'Componentes IA')
        ]
        
        all_good = True
        
        for file_path, description in frontend_files:
            full_path = self.base_path / file_path
            
            if full_path.exists():
                self.log_test(f"Arquivo {description}", True)
                
                # Verificar conte√∫do
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                # Verificar exports esperados
                if 'useAI.ts' in file_path:
                    expected_hooks = [
                        'useSentiment',
                        'useIntelligentChat',
                        'useAIInsights',
                        'useProductivityAnalysis'
                    ]
                    
                    for hook in expected_hooks:
                        if hook in content:
                            self.log_test(f"Hook {hook}", True)
                        else:
                            self.log_test(f"Hook {hook}", False, error="Hook n√£o encontrado")
                            all_good = False
                
                elif 'AIComponents.tsx' in file_path:
                    expected_components = [
                        'IntelligentChat',
                        'AIInsightsPanel',
                        'ProductivityDashboard',
                        'RecommendationsPanel'
                    ]
                    
                    for component in expected_components:
                        if component in content:
                            self.log_test(f"Componente {component}", True)
                        else:
                            self.log_test(f"Componente {component}", False, 
                                        error="Componente n√£o encontrado")
                            all_good = False
                            
            else:
                self.log_test(f"Arquivo {description}", False, error="Arquivo n√£o encontrado")
                all_good = False
        
        return all_good
    
    def test_workflows(self) -> bool:
        """Testa workflows n8n"""
        print("\nüîÑ Testando Workflows n8n")
        print("-" * 50)
        
        workflow_files = [
            'workflows/whatsapp_abacus_workflow.json',
            'workflows/email_intelligent_triage.json',
            'workflows/task_automation_workflow.json',
            'workflows/report_generation_workflow.json'
        ]
        
        all_good = True
        
        for workflow_file in workflow_files:
            full_path = self.base_path / workflow_file
            
            if full_path.exists():
                try:
                    with open(full_path, 'r', encoding='utf-8') as f:
                        workflow_data = json.load(f)
                    
                    # Verificar estrutura b√°sica
                    if 'nodes' in workflow_data and 'connections' in workflow_data:
                        node_count = len(workflow_data['nodes'])
                        self.log_test(f"Workflow {workflow_file}", True, 
                                    f"{node_count} n√≥s")
                        
                        # Verificar se cont√©m n√≥s Abacus.AI
                        abacus_nodes = [
                            node for node in workflow_data['nodes'] 
                            if node.get('type') == 'abacusAI'
                        ]
                        
                        if abacus_nodes:
                            self.log_test(f"N√≥s Abacus.AI em {workflow_file}", True, 
                                        f"{len(abacus_nodes)} n√≥s")
                        else:
                            self.log_test(f"N√≥s Abacus.AI em {workflow_file}", False, 
                                        error="Nenhum n√≥ Abacus.AI encontrado")
                    else:
                        self.log_test(f"Workflow {workflow_file}", False, 
                                    error="Estrutura inv√°lida")
                        all_good = False
                        
                except json.JSONDecodeError as e:
                    self.log_test(f"Workflow {workflow_file}", False, 
                                error=f"JSON inv√°lido: {e}")
                    all_good = False
                except Exception as e:
                    self.log_test(f"Workflow {workflow_file}", False, error=str(e))
                    all_good = False
            else:
                # Alguns workflows s√£o opcionais
                if 'whatsapp_abacus_workflow.json' in workflow_file:
                    self.log_test(f"Workflow {workflow_file}", False, 
                                error="Workflow principal n√£o encontrado")
                    all_good = False
                else:
                    self.log_test(f"Workflow {workflow_file}", True, 
                                "Workflow opcional n√£o presente")
        
        return all_good
    
    def test_documentation(self) -> bool:
        """Testa documenta√ß√£o"""
        print("\nüìö Testando Documenta√ß√£o")
        print("-" * 50)
        
        doc_files = [
            ('README_FASE1.md', 'Documenta√ß√£o Fase 1'),
            ('README_FASE2.md', 'Documenta√ß√£o Fase 2'),
            ('DOCUMENTACAO_TECNICA_COMPLETA.md', 'Documenta√ß√£o T√©cnica'),
            ('CHANGELOG.md', 'Changelog'),
            ('.env.example', 'Exemplo de configura√ß√£o')
        ]
        
        all_good = True
        
        for file_path, description in doc_files:
            full_path = self.base_path / file_path
            
            if full_path.exists():
                size = full_path.stat().st_size
                if size > 1000:  # Pelo menos 1KB
                    self.log_test(f"Doc {description}", True, f"Tamanho: {size} bytes")
                else:
                    self.log_test(f"Doc {description}", False, 
                                error=f"Arquivo muito pequeno: {size} bytes")
                    all_good = False
            else:
                self.log_test(f"Doc {description}", False, error="Arquivo n√£o encontrado")
                all_good = False
        
        return all_good
    
    async def run_integration_tests(self) -> bool:
        """Executa testes de integra√ß√£o das fases anteriores"""
        print("\nüß™ Executando Testes de Integra√ß√£o")
        print("-" * 50)
        
        test_scripts = [
            ('test_integration.py', 'Testes Fase 1'),
            ('test_fase2.py', 'Testes Fase 2')
        ]
        
        all_good = True
        
        for script_name, description in test_scripts:
            script_path = self.base_path / script_name
            
            if script_path.exists():
                try:
                    # Executar script de teste
                    result = subprocess.run(
                        [sys.executable, str(script_path)],
                        capture_output=True,
                        text=True,
                        timeout=120  # 2 minutos timeout
                    )
                    
                    if result.returncode == 0:
                        self.log_test(f"Script {description}", True, 
                                    "Todos os testes passaram")
                    else:
                        self.log_test(f"Script {description}", False, 
                                    error=f"Falhas nos testes: {result.stderr[:200]}")
                        all_good = False
                        
                except subprocess.TimeoutExpired:
                    self.log_test(f"Script {description}", False, 
                                error="Timeout - teste demorou mais que 2 minutos")
                    all_good = False
                except Exception as e:
                    self.log_test(f"Script {description}", False, error=str(e))
                    all_good = False
            else:
                self.log_test(f"Script {description}", False, 
                            error="Script de teste n√£o encontrado")
                all_good = False
        
        return all_good
    
    def generate_report(self) -> str:
        """Gera relat√≥rio final de valida√ß√£o"""
        success_rate = (self.success_count / self.total_tests * 100) if self.total_tests > 0 else 0
        
        self.results["summary"] = {
            "total_tests": self.total_tests,
            "successful_tests": self.success_count,
            "failed_tests": self.total_tests - self.success_count,
            "success_rate": round(success_rate, 2),
            "overall_status": "PASS" if success_rate >= 80 else "FAIL"
        }
        
        # Salvar relat√≥rio JSON
        report_file = self.base_path / f"validation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w', encoding='utf-8') as f:
            json.dump(self.results, f, indent=2, ensure_ascii=False)
        
        return str(report_file)
    
    async def run_all_tests(self) -> bool:
        """Executa todos os testes de valida√ß√£o"""
        print("üîß BestStag v9.1 + Abacus.AI - Valida√ß√£o Final")
        print("=" * 60)
        
        tests = [
            ("Estrutura de Arquivos", self.check_file_structure),
            ("Depend√™ncias Python", self.check_dependencies),
            ("Configura√ß√£o", self.check_configuration),
            ("Integra√ß√£o Abacus.AI", self.test_abacus_integration),
            ("Mem√≥ria Contextual", self.test_contextual_memory),
            ("Estrutura Frontend", self.test_frontend_structure),
            ("Workflows n8n", self.test_workflows),
            ("Documenta√ß√£o", self.test_documentation),
            ("Testes de Integra√ß√£o", self.run_integration_tests)
        ]
        
        overall_success = True
        
        for test_name, test_func in tests:
            try:
                if asyncio.iscoroutinefunction(test_func):
                    result = await test_func()
                else:
                    result = test_func()
                
                if not result:
                    overall_success = False
                    
            except Exception as e:
                print(f"\n‚ùå ERRO em {test_name}: {e}")
                overall_success = False
        
        # Gerar relat√≥rio
        report_file = self.generate_report()
        
        print("\n" + "=" * 60)
        print("üìä RESUMO DA VALIDA√á√ÉO")
        print("=" * 60)
        
        summary = self.results["summary"]
        print(f"Total de Testes: {summary['total_tests']}")
        print(f"Sucessos: {summary['successful_tests']}")
        print(f"Falhas: {summary['failed_tests']}")
        print(f"Taxa de Sucesso: {summary['success_rate']}%")
        print(f"Status Geral: {summary['overall_status']}")
        
        if self.results["recommendations"]:
            print(f"\nüí° RECOMENDA√á√ïES:")
            for i, rec in enumerate(self.results["recommendations"], 1):
                print(f"   {i}. {rec}")
        
        print(f"\nüìÑ Relat√≥rio salvo em: {report_file}")
        
        if overall_success and summary['success_rate'] >= 80:
            print("\nüéâ SUCESSO: BestStag v9.1 + Abacus.AI est√° pronto!")
            print("‚úÖ Todas as funcionalidades principais foram validadas")
            print("üöÄ Sistema pronto para deployment e uso em produ√ß√£o")
        else:
            print("\n‚ö†Ô∏è  ATEN√á√ÉO: Alguns testes falharam")
            print("üîß Revise os problemas identificados antes do deployment")
        
        return overall_success

async def main():
    """Fun√ß√£o principal"""
    validator = BestStagValidator()
    success = await validator.run_all_tests()
    return 0 if success else 1

if __name__ == "__main__":
    exit_code = asyncio.run(main())
    sys.exit(exit_code)

